(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{419:function(e,t,r){"use strict";r.r(t);var a=r(8),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"synchronous-query"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#synchronous-query"}},[e._v("#")]),e._v(" Synchronous query")]),e._v(" "),r("p",[r("Term",{attrs:{term:"workflow",show:"Workflow"}}),e._v(" code is stateful with the Cadence framework preserving it over various software and hardware failures. The state is constantly mutated during "),r("Term",{attrs:{term:"workflow_execution"}}),e._v(". To expose this internal state to the external world Cadence provides a synchronous "),r("Term",{attrs:{term:"query"}}),e._v(" feature. From the "),r("Term",{attrs:{term:"workflow"}}),e._v(" implementer point of view the "),r("Term",{attrs:{term:"query"}}),e._v(" is exposed as a synchronous callback that is invoked by external entities. Multiple such callbacks can be provided per "),r("Term",{attrs:{term:"workflow"}}),e._v(" type exposing different information to different external systems.")],1),e._v(" "),r("p",[e._v("To execute a "),r("Term",{attrs:{term:"query"}}),e._v(" an external client calls a synchronous Cadence API providing "),r("em",[r("Term",{attrs:{term:"domain"}}),e._v(", workflowID, "),r("Term",{attrs:{term:"query"}}),e._v(" name")],1),e._v(" and optional "),r("em",[r("Term",{attrs:{term:"query"}}),e._v(" arguments")],1),e._v(".")],1),e._v(" "),r("p",[r("Term",{attrs:{term:"query",show:"Query"}}),e._v(" callbacks must be read-only not mutating the "),r("Term",{attrs:{term:"workflow"}}),e._v(" state in any way. The other limitation is that the "),r("Term",{attrs:{term:"query"}}),e._v(" callback cannot contain any blocking code. Both above limitations rule out ability to invoke "),r("Term",{attrs:{term:"activity",show:"activities"}}),e._v(" from the "),r("Term",{attrs:{term:"query"}}),e._v(" handlers.")],1),e._v(" "),r("p",[e._v("Cadence team is currently working on implementing "),r("em",[e._v("update")]),e._v(" feature that would be similar to "),r("Term",{attrs:{term:"query"}}),e._v(" in the way it is invoked, but would support "),r("Term",{attrs:{term:"workflow"}}),e._v(" state mutation and "),r("Term",{attrs:{term:"local_activity"}}),e._v(" invocations. From user's point of view, "),r("em",[e._v("update")]),e._v(" is similar to signal + strong consistent query, but implemented in a much less expensive way in Cadence.")],1),e._v(" "),r("h2",{attrs:{id:"stack-trace-query"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#stack-trace-query"}},[e._v("#")]),e._v(" Stack Trace Query")]),e._v(" "),r("p",[e._v("The Cadence client libraries expose some predefined "),r("Term",{attrs:{term:"query",show:"queries"}}),e._v(" out of the box. Currently the only supported built-in "),r("Term",{attrs:{term:"query"}}),e._v(" is "),r("em",[e._v("stack_trace")]),e._v(". This "),r("Term",{attrs:{term:"query"}}),e._v(" returns stacks of all "),r("Term",{attrs:{term:"workflow"}}),e._v(" owned threads. This is a great way to troubleshoot any "),r("Term",{attrs:{term:"workflow"}}),e._v(" in production.")],1)])}),[],!1,null,null,null);t.default=s.exports}}]);