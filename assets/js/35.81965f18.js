(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{419:function(t,e,a){"use strict";a.r(e);var s=a(8),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"cross-dc-replication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cross-dc-replication"}},[t._v("#")]),t._v(" Cross-DC replication")]),t._v(" "),a("p",[t._v("The Cadence Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" feature provides clients with the capability to continue their "),a("Term",{attrs:{term:"workflow_execution"}}),t._v(" from another\ncluster in the event of a datacenter failover. Although you can configure a Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" to be replicated to any number of\nclusters, it is only considered active in a single cluster.")],1),t._v(" "),a("h2",{attrs:{id:"global-domains-architecture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#global-domains-architecture"}},[t._v("#")]),t._v(" Global Domains Architecture")]),t._v(" "),a("p",[t._v("Cadence has introduced a new top level entity, Global "),a("Term",{attrs:{term:"domain",show:"Domains"}}),t._v(", which provides support for replication of "),a("Term",{attrs:{term:"workflow"}}),t._v("\nexecution across clusters. Client applications need to run "),a("Term",{attrs:{term:"worker",show:"workers"}}),t._v(" polling on "),a("Term",{attrs:{term:"activity",show:"Activity"}}),t._v("/"),a("Term",{attrs:{term:"decision_task",show:"Decision_tasks"}}),t._v(" on all clusters.\nCadence will only dispatch tasks on the current active cluster; "),a("Term",{attrs:{term:"worker",show:"workers"}}),t._v(" on the standby cluster will sit idle\nuntil the Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" is failed over.")],1),t._v(" "),a("p",[t._v("Because Cadence is a service that provides highly consistent semantics, we only allow external "),a("Term",{attrs:{term:"event",show:"events"}}),t._v(" like\n"),a("strong",[t._v("StartWorkflowExecution")]),t._v(", "),a("strong",[t._v("SignalWorkflowExecution")]),t._v(", etc. on an active cluster. Global "),a("Term",{attrs:{term:"domain",show:"Domains"}}),t._v(" relies on light-weight\ntransactions (paxos) on the local cluster (Local_Quorum) to update the "),a("Term",{attrs:{term:"workflow_execution"}}),t._v(" state and create replication\n"),a("Term",{attrs:{term:"task",show:"tasks"}}),t._v(" which are applied asynchronously to replicate state across clusters. If an application makes these API calls on a\ncluster where Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" is in standby mode, Cadence will reject those calls with "),a("strong",[t._v("DomainNotActiveError")]),t._v(", which\ncontains the name of the current active cluster. It is the responsibility of the application to forward the external\n"),a("Term",{attrs:{term:"event"}}),t._v(" to the cluster that is currently active.")],1),t._v(" "),a("h2",{attrs:{id:"new-config-for-global-domains"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-config-for-global-domains"}},[t._v("#")]),t._v(" New config for Global Domains")]),t._v(" "),a("h3",{attrs:{id:"isglobal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#isglobal"}},[t._v("#")]),t._v(" IsGlobal")]),t._v(" "),a("p",[t._v("This config is used to distinguish "),a("Term",{attrs:{term:"domain",show:"domains"}}),t._v(" local to the cluster from the global "),a("Term",{attrs:{term:"domain"}}),t._v(". It controls the creation of\nreplication "),a("Term",{attrs:{term:"task",show:"tasks"}}),t._v(" on updates allowing the state to be replicated across clusters. This is a read-only setting that can\nonly be set when the "),a("Term",{attrs:{term:"domain"}}),t._v(" is provisioned.")],1),t._v(" "),a("h3",{attrs:{id:"clusters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clusters"}},[t._v("#")]),t._v(" Clusters")]),t._v(" "),a("p",[t._v("A list of clusters where the "),a("Term",{attrs:{term:"domain"}}),t._v(" can fail over to, including the current active cluster.\nThis is also a read-only setting that can only be set when the "),a("Term",{attrs:{term:"domain"}}),t._v(" is provisioned. A re-replication feature on the\nroadmap will allow updating this config to add/remove clusters in the future.")],1),t._v(" "),a("h3",{attrs:{id:"active-cluster-name"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#active-cluster-name"}},[t._v("#")]),t._v(" Active Cluster Name")]),t._v(" "),a("p",[t._v("Name of the current active cluster for the Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(". This config is updated each time the Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" is failed over to\nanother cluster.")],1),t._v(" "),a("h3",{attrs:{id:"failover-version"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#failover-version"}},[t._v("#")]),t._v(" Failover Version")]),t._v(" "),a("p",[t._v("Unique failover version which also represents the current active cluster for Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(". Cadence allows failover to\nbe triggered from any cluster, so failover version is designed in a way to not allow conflicts if failover is mistakenly\ntriggered simultaneously on two clusters.")],1),t._v(" "),a("h2",{attrs:{id:"conflict-resolution"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conflict-resolution"}},[t._v("#")]),t._v(" Conflict Resolution")]),t._v(" "),a("p",[t._v("Unlike local "),a("Term",{attrs:{term:"domain",show:"domains"}}),t._v(" which provide at-most-once semantics for "),a("Term",{attrs:{term:"activity"}}),t._v(" execution, Global "),a("Term",{attrs:{term:"domain",show:"Domains"}}),t._v(" can only support at-least-once\nsemantics. Cadence XDC relies on asynchronous replication of "),a("Term",{attrs:{term:"event",show:"events"}}),t._v(" across clusters, so in the event of a failover\nit is possible that "),a("Term",{attrs:{term:"activity"}}),t._v(" gets dispatched again on the new active cluster due to a replication "),a("Term",{attrs:{term:"task"}}),t._v(" lag. This also\nmeans that whenever "),a("Term",{attrs:{term:"workflow_execution"}}),t._v(" is updated after a failover by the new cluster, any previous replication "),a("Term",{attrs:{term:"task",show:"tasks"}}),t._v("\nfor that execution cannot be applied. This results in loss of some progress made by the "),a("Term",{attrs:{term:"workflow_execution"}}),t._v(" in the\nprevious active cluster. During such conflict resolution, Cadence re-injects any external "),a("Term",{attrs:{term:"event",show:"events"}}),t._v(" like "),a("Term",{attrs:{term:"signal",show:"Signals"}}),t._v(" to the\nnew history before discarding replication "),a("Term",{attrs:{term:"task",show:"tasks"}}),t._v(". Even though some progress could rollback during failovers, Cadence\nprovides the guarantee that "),a("Term",{attrs:{term:"workflow",show:"workflows"}}),t._v(" wonâ€™t get stuck and will continue to make forward progress.")],1),t._v(" "),a("h2",{attrs:{id:"visibility-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#visibility-api"}},[t._v("#")]),t._v(" Visibility API")]),t._v(" "),a("p",[t._v("All Visibility APIs are allowed on both active and standby clusters. This enables\n"),a("a",{attrs:{href:"https://github.com/uber/cadence-web",target:"_blank",rel:"noopener noreferrer"}},[t._v("Cadence Web"),a("OutboundLink")],1),t._v(" to work seamlessly for Global "),a("Term",{attrs:{term:"domain",show:"Domains"}}),t._v(" as all visibility records for\n"),a("Term",{attrs:{term:"workflow_execution",show:"workflow_executions"}}),t._v(" can be queried from any cluster the "),a("Term",{attrs:{term:"domain"}}),t._v(" is replicated to. Applications making API calls directly\nto the Cadence Visibility API will continue to work even if a Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" is in standby mode. However, they might see\na lag due to replication delay when "),a("Term",{attrs:{term:"query",show:"querying"}}),t._v(" the "),a("Term",{attrs:{term:"workflow_execution"}}),t._v(" state from a standby cluster.")],1),t._v(" "),a("h2",{attrs:{id:"cli"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cli"}},[t._v("#")]),t._v(" CLI")]),t._v(" "),a("p",[t._v("The Cadence "),a("Term",{attrs:{term:"CLI"}}),t._v(" can also be used to "),a("Term",{attrs:{term:"query"}}),t._v(" the "),a("Term",{attrs:{term:"domain"}}),t._v(" config or perform failovers. Here are some useful commands.")],1),t._v(" "),a("h3",{attrs:{id:"query-global-domain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#query-global-domain"}},[t._v("#")]),t._v(" Query Global Domain")]),t._v(" "),a("p",[t._v("The following command can be used to describe Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" metadata:")],1),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ cadence --do cadence-canary-xdc d desc\nName: cadence-canary-xdc\nDescription: cadence canary cross "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("dc")]),t._v(" testing domain\nOwnerEmail: cadence-dev@cadenceworkflow.io\nDomainData:\nStatus: REGISTERED\nRetentionInDays: "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),t._v("\nEmitMetrics: "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\nActiveClusterName: dc1\nClusters: dc1, dc2\n")])])]),a("h3",{attrs:{id:"failover-global-domain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#failover-global-domain"}},[t._v("#")]),t._v(" Failover Global Domain")]),t._v(" "),a("p",[t._v("The following command can be used to failover Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" "),a("em",[t._v("my-domain-global")]),t._v(" to the "),a("em",[t._v("dc2")]),t._v(" cluster:")],1),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("$ cadence --do my-domain-global d up --ac dc2\n")])])]),a("h2",{attrs:{id:"running-locally"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#running-locally"}},[t._v("#")]),t._v(" Running Locally")]),t._v(" "),a("p",[t._v("The best way is to use Cadence "),a("a",{attrs:{href:"https://github.com/uber/cadence/tree/master/docker",target:"_blank",rel:"noopener noreferrer"}},[t._v("docker-compose"),a("OutboundLink")],1),t._v(":\n"),a("code",[t._v("docker-compose -f docker-compose-multiclusters.yml up")])]),t._v(" "),a("h2",{attrs:{id:"running-in-production"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#running-in-production"}},[t._v("#")]),t._v(" Running in Production")]),t._v(" "),a("p",[t._v("Enable global domain feature needs to be enabled in "),a("RouterLink",{attrs:{to:"/docs/operation-guide/setup/#static-configs"}},[t._v("static config")]),t._v(".")],1),t._v(" "),a("p",[t._v('Here we use clusterDCA and clusterDCB as an example. We pick clusterDCA as the primary(used to called "master") cluster.\nThe only difference of being a primary cluster is that it is responsible for domain registration. Primary can be changed later but it needs to be the same across all clusters.')]),t._v(" "),a("p",[t._v("The ClusterMeta config of clusterDCA should be")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clusterMetadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enableGlobalDomain")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("failoverVersionIncrement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("masterClusterName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"clusterDCA"')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("currentClusterName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"clusterDCA"')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clusterInformation")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clusterDCA")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enabled")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("initialFailoverVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rpcName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cadence-frontend"')]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rpcAddress")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"<>:<>"')]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clusterDCB")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enabled")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("initialFailoverVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rpcName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cadence-frontend"')]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rpcAddress")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"<>:<>"')]),t._v("\n")])])]),a("p",[t._v("And ClusterMeta config of clusterDCB should be")]),t._v(" "),a("div",{staticClass:"language-yaml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clusterMetadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enableGlobalDomain")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("failoverVersionIncrement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("masterClusterName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"clusterDCA"')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("currentClusterName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"clusterDCB"')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clusterInformation")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clusterDCA")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enabled")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("initialFailoverVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rpcName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cadence-frontend"')]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rpcAddress")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"<>:<>"')]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("clusterDCB")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("enabled")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean important"}},[t._v("true")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("initialFailoverVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rpcName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cadence-frontend"')]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("rpcAddress")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"<>:<>"')]),t._v("\n")])])]),a("p",[t._v("After the configuration is deployed:")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("Register a global domain\n"),a("code",[t._v("cadence --do <domain_name> domain register --global_domain true --clusters clusterDCA clusterDCB --active_cluster clusterDCA")])])]),t._v(" "),a("li",[a("p",[t._v("Run some workflow and failover domain from one to another\n"),a("code",[t._v("cadence --do <domain_name> domain update --active_cluster clusterDCB")])])])]),t._v(" "),a("p",[t._v("Then the domain should be failed over to clusterDCB. Now worklfows are read-only in clusterDCA. So your workers polling tasks from clusterDCA will become idle.")]),t._v(" "),a("p",[t._v("Note 1: that even though clusterDCA is standy/read-only for this domain, it can be active for another domain. So being active/standy is per domain basis not per clusters. In other words, for example if you use XDC in case of DC failure of clusterDCA, you need to failover all domains from clusterDCA to clusterDCB.")]),t._v(" "),a("p",[t._v("Note 2: even though a domain is standy/read-only in a cluster, say clusterDCA, sending write requests(startWF, signalWF, etc) could still work because there is a forwarding component in the Frontend service. It will try to re-route the requests to an active cluster for the domain.")]),t._v(" "),a("h2",{attrs:{id:"faq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[t._v("#")]),t._v(" FAQ")]),t._v(" "),a("h3",{attrs:{id:"what-happens-to-outstanding-activities-after-failover"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-happens-to-outstanding-activities-after-failover"}},[t._v("#")]),t._v(" What happens to outstanding activities after failover?")]),t._v(" "),a("p",[t._v("Cadence does not forward "),a("Term",{attrs:{term:"activity"}}),t._v(" completions across clusters. Any outstanding "),a("Term",{attrs:{term:"activity"}}),t._v(" will eventually timeout based\non the configuration. Your application should have retry logic in place so that the "),a("Term",{attrs:{term:"activity"}}),t._v(" gets retried and dispatched\nagain to a "),a("Term",{attrs:{term:"worker"}}),t._v(" after the failover to the new DC. Handling this is pretty much the same as "),a("Term",{attrs:{term:"activity"}}),t._v(" timeout caused by\na "),a("Term",{attrs:{term:"worker"}}),t._v(" restart even without Global "),a("Term",{attrs:{term:"domain",show:"Domains"}}),t._v(".")],1),t._v(" "),a("h3",{attrs:{id:"what-happens-when-a-start-or-signal-api-call-is-made-to-a-standby-cluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-happens-when-a-start-or-signal-api-call-is-made-to-a-standby-cluster"}},[t._v("#")]),t._v(" What happens when a start or signal API call is made to a standby cluster?")]),t._v(" "),a("p",[t._v("Cadence will reject the call and return "),a("strong",[t._v("DomainNotActiveError")]),t._v(". It is the responsibility of the application to forward\nthe failed call to active cluster based on information provided in the error.")]),t._v(" "),a("h3",{attrs:{id:"what-is-the-recommended-pattern-to-send-external-events-to-an-active-cluster"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-is-the-recommended-pattern-to-send-external-events-to-an-active-cluster"}},[t._v("#")]),t._v(" What is the recommended pattern to send external events to an active cluster?")]),t._v(" "),a("p",[t._v("The recommendation at this point is to publish "),a("Term",{attrs:{term:"event",show:"events"}}),t._v(" to a Kafka topic if they can be generated in any DC.\nThen, have a consumer that consumes from the aggregated Kafka topic in the same DC and sends them to Cadence. Both the\nKafka consumer and Global "),a("Term",{attrs:{term:"domain",show:"Domain"}}),t._v(" need to be failed over together.")],1)])}),[],!1,null,null,null);e.default=r.exports}}]);